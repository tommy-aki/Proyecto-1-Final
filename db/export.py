from db.querries import query
from collections import defaultdict
from datetime import date, datetime
import re
import binascii

type_dict = {
    "TINYINT(1)": "BOOLEAN",
    "TINYINT UNSIGNED" : "SMALLINT",
    "SMALLINT UNSIGNED" : "INTEGER",
    "INT": "INTEGER",
    "INT UNSIGNED": "BIGINT",
    "MEDIUMINT" : "BIGINT",
    "MEDIUMINT UNSIGNED" : "BIGINT",
    "DECIMAL": "NUMERIC",
    "FLOAT" : "REAL",
    "DOUBLE" : "DOUBLE PRECISION",
    "DATETIME": "TIMESTAMP",
    "YEAR" : "INTEGER",
    "BLOB" : "BYTEA",
    "GEOMETRY" : "TEXT" # Tipo que ocupa una libreria
}

def export(conexion, con_pg):  
    cur_pg = con_pg.cursor()
    with open("PGDDL.sql", "w") as f:  
        cols, rows = query(conexion, f"SHOW FULL TABLES WHERE Table_type='BASE TABLE';")
        indexes = defaultdict(list)
        foraneas = defaultdict(list)
        

        # CREAR LAS TABLAS
        for row in rows:
            primary_keys = []
            table_name = row[cols[0]]
            ddl = f"DROP TABLE IF EXISTS \"{table_name}\" CASCADE;\nCREATE TABLE \"{table_name}\"(\n"
            ccol, crow = query(conexion, f"SHOW COLUMNS FROM `{table_name}`;")

            newCols = []

            column_defs = []
            for r in crow:
                name = r[ccol[0]]
                mysql_type = r[ccol[1]].upper()
                if mysql_type == "GEOMETRY":
                    continue
                pg_type = type_dict.get(mysql_type, mysql_type)
                if "SET(" in mysql_type:
                    pg_type = "TEXT[]"
                elif "ENUM(" in mysql_type:
                    match = re.search(r"ENUM\((.*)\)", mysql_type, re.IGNORECASE)
                    pg_type = f"TEXT CHECK({name} in({match.group(1)}))"
                newCols.append((name, pg_type))

                is_null = "NOT NULL" if r[ccol[2]] == "NO" else ""
                if r[ccol[4]] in ("0","1") and pg_type == "BOOLEAN":
                    default = "DEFAULT TRUE" if r[ccol[4]] == "1" else "DEFAULT FALSE"
                elif any(t in pg_type for t in ("TEXT", "CHAR", "VARCHAR")):
                    default = f"DEFAULT '{r[ccol[4]]}'" if r[ccol[4]] else ""
                else:
                    default = f"DEFAULT {r[ccol[4]]}" if r[ccol[4]] else ""
                if r[ccol[3]] == "PRI":
                    primary_keys.append(name)
                auto_inc = "GENERATED BY DEFAULT AS IDENTITY" if r[ccol[5]] == "auto_increment" else ""

                parts = [pg_type, is_null, auto_inc, default]
                column_def = ' '.join(p for p in parts if p)
                column_defs.append(f'"{name}" {column_def}')
            
            if primary_keys:
                pk_str = f",\n  PRIMARY KEY ({', '.join(f'\"{pk}\"' for pk in primary_keys)})"
            else:
                pk_str = ""
            ddl += "  " + ",\n  ".join(column_defs) + pk_str + "\n);\n\n"

            #f.write(ddl) 
            try:
                cur_pg.execute(ddl)
            except Exception as e:
                print(f"Error creando tabla {table_name}: {e}")

            #OBTENER TODOS LOS CONSTRAINTS DE LLAVE FORANEA
            cccol, ccrow = query(conexion, f"SHOW CREATE TABLE `{table_name}`")
            pattern = re.findall(r'CONSTRAINT\s+`?(\w+)`?\s+FOREIGN KEY\s+\((.*?)\)\s+REFERENCES\s+`?(\w+)`?\s+\((.*?)\)', ccrow[0][cccol[1]])

            for_cols = set()
            for constraint, lcol, rtab, rcol in pattern:

                co = [c.strip(" `") for c in lcol.split(",")]
                for_cols.update(co)
                foraneas[constraint].append({
                    "table" : f"\"{table_name}\"",
                    "lcol": lcol.replace('`', '"'),
                    "rtab" : f"\"{rtab}\"",
                    "rcol":rcol.replace('`', '"')
                })

            #OBTENER Y FILTRAR TODOS LOS INDICES
            icol, irow = query(conexion, f"SHOW INDEX FROM `{table_name}`") 
            for r in irow:
                if r[icol[2]] != "PRIMARY" and r[icol[4]] not in for_cols:
                    indexes[r[icol[2]]].append({
                        "table": f"\"{table_name}\"",
                        "column": f"\"{r[icol[4]]}\"",
                        "non_unique": r[icol[1]]
                    })

            #OBTENER LOS DATOS
            newColsStr = ",".join(col[0] for col in newCols)
            columns, data = query(conexion, f"SELECT {newColsStr} FROM {table_name}")
            colnames = [f'"{c}"' for c in columns]
            colnames = colnames
            colstr = ', '.join(colnames)
            ddl = f"INSERT INTO {table_name}({colstr})\n"
            ddl += f"VALUES\n"
            values = []

            for entry in data:
                value_entry = []
                for col, type in newCols:
                    val = entry[col]
                    if val is None:
                        value_entry.append("NULL")
                    elif isinstance(val, str):
                        new_val = val.replace("'", "''")
                        value_entry.append(f"'{new_val}'")
                    elif isinstance(val, (date, datetime)):
                        new_val = val.strftime('%Y-%m-%d %H:%M:%S')
                        value_entry.append(f"'{new_val}'")
                    elif isinstance(val, (bytes, bytearray)):
                        new_hex = binascii.hexlify(val).decode("utf-8")
                        value_entry.append(f"'{new_hex}'")
                    elif isinstance(val, (list, set, tuple)):
                        safe_items = [str(v).replace("'", "''") for v in val]
                        value_entry.append(f"ARRAY[{','.join(f"'{c}'" for c in safe_items)}]")
                    elif type == "BOOLEAN":
                        new_bool = "TRUE" if val == 1 else "FALSE"
                        value_entry.append(new_bool)
                    else:
                        value_entry.append(str(val))

                valstr = '  (' + ', '.join(value_entry) + ')'
                values.append(valstr)
            ddl += ',\n'.join(values) + ";\n\n"

            #f.write(ddl)
            try:
                cur_pg.execute(ddl)
            except Exception as e:
                print(f"Error insertando en la tabla {table_name}: {e}")

        #AGREGAR LAS LLAVES FORANEAS
        for constraint_name, entries in foraneas.items():
            for entry in entries:

                ddl = f"""ALTER TABLE {entry["table"]}
  ADD CONSTRAINT {constraint_name}
  FOREIGN KEY ({entry["lcol"]})
  REFERENCES {entry["rtab"]}({entry["rcol"]});\n\n"""
                #f.write(ddl)
                try:
                    cur_pg.execute(ddl)
                except Exception as e:
                    print(f"Error agregando constraints para la tabla {entry["table"]}: {e}")

        #AGREGAR LOS INDICES
        for id_name, entries in indexes.items():
            table = entries[0]["table"] 
            columnas = ", ".join(entry["column"] for entry in entries)
            unique = "UNIQUE " if entries[0]["non_unique"] == 0 else ""

            ddl = f"CREATE {unique}INDEX {id_name} ON {table}({columnas});\n\n"
            # f.write(ddl)
            try:
                cur_pg.execute(ddl)
                con_pg.commit()
            except Exception as e:
                con_pg.rollback()
                print(f"Warning: no se pudo crear el índice {id_name} en {table}: {e}")

        #AGREGAR LAS VIEWS
        view_col, view_row = query(conexion, f"SHOW FULL TABLES WHERE Table_type='VIEW';")
        for vr in view_row:
            view_name = vr[view_col[0]]
            ddl_col, ddl_row = query(conexion, f"SHOW CREATE VIEW {view_name}")
            sql = ddl_row[0][ddl_col[1]]
            if 'group_concat(distinct' in sql:
                continue
            options, select = sql.split('select', 1)
            select = select.replace('`', '"')
            select = select.replace('group_concat', 'STRING_AGG')
            select = select.replace('_utf8mb4', '')
            select = select.replace('separator', ',')

            pattern = re.compile(r"IF\s*\(([^,]+),([^,]+),([^)]+)\)", re.IGNORECASE)
            while True:
                m = pattern.search(select)
                if not m:
                    break
                cond, val_true, val_false = m.groups()
                case_expr = f"(CASE WHEN {cond.strip()} THEN {val_true.strip()} ELSE {val_false.strip()} END)"
                select = select[:m.start()] + case_expr + select[m.end():]

            ddl = f"CREATE OR REPLACE VIEW {view_name} AS \n  SELECT {select};"
            
            #f.write(ddl + "\n\n")
            try:
                cur_pg.execute(ddl)
            except Exception as e:
                print(f"Error creando view {view_name}: {e}")

        con_pg.commit()
        cur_pg.close()




        # for index_name, entries in indexes.items():
        #     print(f"Índice: {index_name}")
        #     for entry in entries:
        #         table = entry["table"]
        #         column = entry["column"]
        #         unique = entry["unique"]
        #         print(f"  Tabla: {table}, Columna: {column}, Unique: {unique}")

        # for foranea, entries in foraneas.items():
        #     print(f"Llave Foránea: {foranea}")
        #     for entry in entries:
        #         tab = entry["table"]
        #         lcol = entry["lcol"]
        #         rtab = entry["rtab"]
        #         rcol = entry["rcol"]
        #         print(f"  Tabla: {tab}, Columna: {lcol}, Tabla Referencia: {rtab}, Columna Referencia: {rcol}")





            
